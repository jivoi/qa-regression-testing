#!/usr/bin/python
#
#    test-txt2man.py quality assurance test script for txt2man
#    Copyright (C) 2013 Canonical Ltd.
#    Author: Marc Deslauriers <marc.deslauriers@canonical.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License version 3,
#    as published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# packages required for test to run:
# QRT-Packages: txt2man
# packages where more than one package can satisfy a runtime requirement:
# QRT-Alternates: 

'''
    In general, this test should be run in a virtual machine (VM) or possibly
    a chroot and not on a production machine. While efforts are made to make
    these tests non-destructive, there is no guarantee this script will not
    alter the machine. You have been warned.

    How to run in a clean VM:
    $ ./make-test-tarball test-<script>.py     # creates tarball in /tmp/
    $ scp /tmp/qrt-test-<script>.tar.gz root@vm.host:/tmp
    on VM:
    # cd /tmp ; tar zxvf ./qrt-test-<script>.tar.gz
    # cd /tmp/qrt-test-<script> ; ./install-packages ./test-<script>.py
    # ./test-<script>.py -v

    To run in all VMs named sec*:
    $ vm-qrt -p sec test-<script.py>

    ### TODO: update for ./install-packages step ###
    How to run in a clean schroot named 'lucid':
    $ schroot -c lucid -u root -- sh -c 'apt-get -y install lsb-release <QRT-Packages> && ./test-PKG.py -v'
'''


import os
import subprocess
import sys
import unittest
import tempfile
import testlib

try:
    from private.qrt.Txt2man import PrivateTxt2manTest
except ImportError:
    class PrivateTxt2manTest(object):
        '''Empty class'''
    print >>sys.stdout, "Skipping private tests"


class Txt2manTest(testlib.TestlibCase, PrivateTxt2manTest):
    '''Test txt2man.'''

    def setUp(self):
        '''Set up prior to each test_* function'''
        self.tempdir = tempfile.mkdtemp(dir='/tmp',prefix="txt2man-")
        self.txtfile = os.path.join(self.tempdir, "test.txt")

    def tearDown(self):
        '''Clean up after each test_* function'''
        if os.path.exists(self.tempdir):
            testlib.recursive_rm(self.tempdir)

    def _create_text(self):
        '''Creates a text file for testing'''
        contents = '''DEBORK(1)

NAME
    debork - debork de-borks files

SYNOPSIS
    debork [-f] file...

DESCRIPTION
    allows removing borks from almost any file.

OPTIONS
    -f
        Enabled flatulence mode.

DEBORK(1)'''

        testlib.create_fill(self.txtfile, contents, mode=0755)


    def test_txt2man(self):
        '''Test txt2man'''

        self._create_text()

        manpage = r'''.\"Text automatically generated by txt2man
.TH debork  "1 April 2013" "" ""
.RS
\fBDEBORK\fP(1)
.SH NAME
\fBdebork \fP- debork de-borks files
\fB
.SH SYNOPSIS
.nf
.fam C
  \fBdebork\fP [\fB-f\fP] file\.\.\.

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
allows removing borks from almost any file.
.SH OPTIONS
\fB-f\fP
Enabled flatulence mode.
.RE
.PP
\fBDEBORK\fP(1)
'''

        rc, report = testlib.cmd(['txt2man', '-t', 'debork', '-d', '1 April 2013', self.txtfile])
        expected = 0
        result = 'Got exit code %d, expected %d\n' % (rc, expected)
        self.assertEquals(expected, rc, result + report)

        result = "txt2man output isn't what was expected!: '%s' instead of '%s'\n" % (report, manpage)
        self.assertEqual(report, manpage, result)

    def test_cve_2013_1444(self):
        '''Test CVE-2013-1444'''

        bad_file = '/tmp/2222'
        if os.path.exists(bad_file):
            testlib.recursive_rm(bad_file)

        self._create_text()

        rc, report = testlib.cmd(['txt2man', '-t', 'debork', '-d', '1 April 2013', self.txtfile])
        expected = 0
        result = 'Got exit code %d, expected %d\n' % (rc, expected)
        self.assertEquals(expected, rc, result + report)

        result = "Found /tmp/2222!\n"
        self.assertFalse(os.path.exists(bad_file), result)


if __name__ == '__main__':
    # simple
    unittest.main()

    # more configurable
    #suite = unittest.TestSuite()
    #suite.addTest(unittest.TestLoader().loadTestsFromTestCase(PkgTest))
    #rc = unittest.TextTestRunner(verbosity=2).run(suite)
    #if not rc.wasSuccessful():
    #    sys.exit(1)
